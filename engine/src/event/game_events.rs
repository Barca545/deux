//combat needs to register the entity id of the attack that hit 
// and the id of the entity that was hit
//does it need a timestamp/tickstamp?

// use std::collections::HashMap;

use crate::component_lib::Owner;

// so maybe what I can do is instad of the event holding the timestamp I have a hashmap with timestamps as the index
//then it just listens for events in the current tick and discards the rest?  
pub enum GameEvent{
  //Combat events
  AutoAttackStart{owner: Owner},
  AutoAttackHit{attack_id: usize},
}


///A sturcture which tracks the game events. Does not track input or other changes.
pub struct GameEventQueue{
  //takes a count as the index and a game event vec as the data
  //count will have to be an int generated by the timer
  events:Vec<GameEvent>
}

impl GameEventQueue {
  pub fn add_event(&mut self, event:GameEvent){
    self.events.push(event);
  }
  
  //this should take in an event type 
  //debating if it should take in the system as an fn mut as an argument or just spit out the events that match the requested type
  //for not let's just have it return all the events matching the timestamp and type
  pub fn process_events(&mut self, call_back: &dyn Fn(&mut GameEvent)){
    for event in &mut self.events {
      call_back(event)
    }
  }

  // pub fn map<U: ?Sized, F>(mut orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>
  // where
  //     F: FnOnce(&mut T) -> &mut U,
  // {
  //     let value = NonNull::from(f(&mut *orig));
  //     RefMut { value, borrow: orig.borrow, marker: PhantomData }
  // }
}


//ok new plan each system just registers events and then I have a resolve ticks system at the end that consumes all of the events


